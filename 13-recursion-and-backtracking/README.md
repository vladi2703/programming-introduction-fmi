# Търсене с връщане и рекурсия

## Задача - Палиндром 
Напишете функция, която проверява дали даден низ е палиндром. За решението използвайте рекурсия.

## Задача - Монотонно растяща
Да се напише рекурсивна програма, която проверява дали редицата **а<sub>0</sub>**, **а<sub>1</sub>**, …, **а<sub>n-1</sub>** е монотонно растяща.

## Задача - Най-малък елемент
Напишете функция, която намира най-малкия елемент в масив и връща индекса му. За решението използвайте рекурсия. След това използвайте току-що написаната функция, за да сортирате масива. Отново - забранява се използването на цикли. Позволено е използването на вградени функции (std::swap) за сравняване и разменяне на елементи.



## Задача - Пълно изчерпване
Напишете програма, която отпечатва всички редици от естествени числа с дължина k, в които числата имат стойности от 1 до n. На вход са дадени естествените числа n и k.  
Пример:  
Вход:
```
3 2
```
Изход:
```
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
```

## Задача - Пермутации
Напишете програма, която отпечатва всички пермутации на числата от 1 до n. На вход е дадено естественото число n.  
Пример:  
Вход:
```
3
```
Изход:
```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

## Задача - Кръстословица
Дадена е таблица nxn от малки латински букви. Напишете функция, която при поадедени таблицата, низ word и n, определя дали word може да се образува от последователност от съседни в таблицата елементи, без един елемент да се използва два пъти.  

Ограничения:  
n <= 10;  strlen(word) <= nxn  

Пример:  
![image](https://user-images.githubusercontent.com/107109124/210225171-dd9bd617-45c8-472d-aee9-d565414ce2d3.png)  
Функцията трябва да върна false и за низа "cahat"

## Задача - Лабиринт

Да се напише функция, която намира път в лабиринт. Лабиринтът е представен като двумерен масив от {0,1}. 0 означава свободна клетка, а 1 - стена. Началната позиция е в ляво горе ъгъл, а крайната - в дясно долен. Примерно използване на функцията:  
```c++
int main()
{
    int maze[N][N] = {
        {0, 0, 0, 0, 1, 0},
        {0, 1, 1, 0, 1, 0},
        {0, 0, 0, 0, 0, 0},
        {0, 1, 1, 1, 1, 0},
        {0, 0, 0, 0, 1, 0},
    };
    int path[N][N];
    int pathLength = 0;
    bool found = findPath(maze, 0, 0, 4, 5, path, pathLength);
}
```
Функцията трябва да върне true и да запише в path и pathLength дължината на намерения път и самия път.
